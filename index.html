<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="icon" href="/favicon.ico"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0"><meta name="generator" content="Astro v5.16.15"><title>Orfanato en vivo</title><link rel="stylesheet" href="/_astro/index.DFLXjtKW.css"></head> <body> <picture class="background-image"> <source srcset="/_astro/2xl.BgikJegv_ZO9oJf.webp" media="(min-width: 1536px)"> <source srcset="/_astro/xl.CQgs1k2s_Z2qYKJS.webp" media="(min-width: 1280px)"> <source srcset="/_astro/lg.C9_0pAF2_Z1TvnYz.webp" media="(min-width: 1024px)"> <source srcset="/_astro/md.wmOCEnBa_Z28YFlp.webp" media="(min-width: 768px)"> <source srcset="/_astro/sm.BVGn0tsD_Z21pPRw.webp" media="(min-width: 640px)"> <img src="/_astro/xs.PkomG8vU_1Et0eq.webp" alt="" aria-hidden="true" class="background-image__img"> </picture> <div class="background-overlay"></div> <main class="countdown-wrapper"> <div class="orphan-countdown" data-astro-cid-gwlgw4sr> <div class="orphan-countdown__panel" data-astro-cid-gwlgw4sr> <output id="orphan-countdown-display" class="orphan-countdown__time" for="countdown" data-astro-cid-gwlgw4sr>
00:00:00
</output> </div> <img src="/fecha.png" alt="04/02/2026" class="orphan-countdown__date" width="801" height="201" data-astro-cid-gwlgw4sr> </div> <script>(function(){const targetISO = "2026-02-05T00:30:00.000Z";

  const display = document.getElementById('orphan-countdown-display');
  if (!display) throw new Error('OrphanCountdown: display element not found');

  const target = new Date(targetISO);

  function pad(n, len) {
    return String(n).padStart(len, '0');
  }

  function tick() {
    const now = Date.now();
    const diff = Math.max(0, target.getTime() - now);

    if (diff <= 0) {
      display.textContent = '00:00:00';
      return;
    }

    const totalSeconds = Math.floor(diff / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;

    display.textContent = `${pad(hours, 2)}:${pad(minutes, 2)}:${pad(seconds, 2)}`;
  }

  tick();
  const interval = setInterval(tick, 1000);
})();</script>  </main> <section class="acertijo-section"> <img src="/_astro/ACERTIJO01.BqG9oQP5_ZEtwJU.webp" alt="Acertijo 1" class="acertijo-image" loading="lazy"> </section> <script>
	// Handle scroll-based transition effects
	function initScrollTransition() {
		const backgroundImg = document.querySelector('.background-image__img');
		const backgroundOverlay = document.querySelector('.background-overlay');
		const acertijoImage = document.querySelector('.acertijo-image');
		
		if (!backgroundImg || !backgroundOverlay || !acertijoImage) return;
		if (!(backgroundImg instanceof HTMLElement) || !(backgroundOverlay instanceof HTMLElement) || !(acertijoImage instanceof HTMLElement)) return;

		function updateScrollEffects() {
			const scrollY = window.scrollY;
			const windowHeight = window.innerHeight;
			const acertijoSection = document.querySelector('.acertijo-section');
			if (!acertijoSection) return;

			const acertijoRect = acertijoSection.getBoundingClientRect();
			const acertijoTop = acertijoRect.top + scrollY;
			const transitionStart = Math.max(0, acertijoTop - windowHeight * 1.5);
			const transitionEnd = acertijoTop;
			const transitionRange = transitionEnd - transitionStart;
			
			let scrollProgress = 0;
			if (transitionRange > 0) {
				scrollProgress = Math.max(0, Math.min(1, (scrollY - transitionStart) / transitionRange));
			} else if (scrollY >= acertijoTop) {
				scrollProgress = 1;
			}

			// Check if acertijo section is in viewport
			const isSectionInView = acertijoRect.top < windowHeight && acertijoRect.bottom > 0;

			// Blur background image (0 to 20px blur)
			const blurAmount = scrollProgress * 20;
			backgroundImg.style.filter = `blur(${blurAmount}px)`;

			// Fade in white overlay (0 to 1 opacity)
			backgroundOverlay.style.opacity = String(scrollProgress);

			// Fade in acertijo image during transition, but ensure it's 100% when section is in view
			const imageFadeStart = 0.3;
			const imageFadeEnd = 0.8;
			let imageOpacity = 1; // Default to fully visible
			
			// Only apply fade effect during transition phase, and only if section is not yet in view
			if (!isSectionInView && scrollProgress > 0 && scrollProgress < imageFadeEnd) {
				if (scrollProgress <= imageFadeStart) {
					imageOpacity = 0;
				} else {
					imageOpacity = (scrollProgress - imageFadeStart) / (imageFadeEnd - imageFadeStart);
				}
			}
			// If section is in view or we've passed the transition, ensure full opacity
			if (isSectionInView || scrollProgress >= imageFadeEnd) {
				imageOpacity = 1;
			}
			
			acertijoImage.style.opacity = String(imageOpacity);
		}

		// Throttle scroll events for performance
		let ticking = false;
		function onScroll() {
			if (!ticking) {
				window.requestAnimationFrame(() => {
					updateScrollEffects();
					ticking = false;
				});
				ticking = true;
			}
		}

		window.addEventListener('scroll', onScroll, { passive: true });
		updateScrollEffects(); // Initial call

		// Fallback: Use Intersection Observer to ensure image is visible when in viewport
		const observer = new IntersectionObserver((entries) => {
			entries.forEach(entry => {
				if (entry.isIntersecting) {
					const img = entry.target.querySelector('.acertijo-image');
					if (img && img instanceof HTMLElement) {
						img.style.opacity = '1';
					}
				}
			});
		}, {
			threshold: 0.1
		});

		const acertijoSectionForObserver = document.querySelector('.acertijo-section');
		if (acertijoSectionForObserver) {
			observer.observe(acertijoSectionForObserver);
		}
	}

	// Initialize when DOM is ready
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initScrollTransition);
	} else {
		initScrollTransition();
	}
</script></body></html>
